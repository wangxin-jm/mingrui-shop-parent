# 商城项目流程搭建

##  创建父项目

mingrui-shop-parent

### 	删除src文件夹


父工程不需要写任何工程代码

在pom.xml导入相关的依赖

```java
<properties>
    <!--项目构建编码-->
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF8</project.reporting.outputEncoding>
    <!--声明JDK版本-->
    <java.version>1.8</java.version>
    <!--spring cloud 版本.注意此版本是建立在boot2.2.2版本上的-->
    <mr.spring.cloud.version>Hoxton.SR1</mr.spring.cloud.version>
</properties>

<!--boot 版本-->
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.3.1.RELEASE</version>
    <!--始终从仓库中获取，不从本地路径获取-->
    <relativePath />
</parent>
<dependencies>
    <!-- 集成commons工具类 -->
    <dependency>
        <groupId>org.apache.commons</groupId>
        <artifactId>commons-lang3</artifactId>
    </dependency>
    <!-- 集成lombok 框架 -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <!--junit测试-->
    <dependency>
        <groupId>junit</groupId>
        <artifactId>junit</artifactId>
    </dependency>
    <!-- SpringBoot整合eureka客户端 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
    </dependency>
    <!--boot 测试模块-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
<!-- 项目依赖,子级模块可以继承依赖-->
<dependencyManagement>
<dependencies>
<!--cloud 依赖-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>${mr.spring.cloud.version}</version>
        <type>pom</type>
        <!--解决maven单继承的问题-->
        <scope>import</scope>
    </dependency>
</dependencies>
</dependencyManagement>
<!-- 注意： 这里必须要添加， 否者各种依赖有问题 -->
<repositories>
    <repository>
        <id>spring-milestones</id>
        <name>Spring Milestones</name>
        <url>https://repo.spring.io/libs-milestone</url>
        <snapshots>
            <enabled>false</enabled>
        </snapshots>
    </repository>
</repositories>
```

## 在创建基础的父工程

1. 在mingrui-shop-parent 工程名上右键-->new-->module
2. 2. 项目名为: mingrui-shop-basics

### 删除src文件夹

父工程不需要写任何代码

#### 配置pom.xml

```
<!--父级项目不需要打包所有packging的类型为pom-->
<packaging>pom</packaging>
```

## 创建公共(工具)工程

1. 在mingrui-shop-parent 工程名上右键-->new-->module 

2. 项目名为: mingrui-shop-commoms

   ### 删除src文件夹

   父工程不需要写任何代码

   #### pom.xml

   <!--父级项目不需要打包所有packging的类型为pom-->
   <packaging>pom</packaging>

   ## 创建服务实现工程

3. 在mingrui-shop-parent 工程名上右键-->new-->module 

4. 项目名为: mingrui-shop-service

#### 删除src

因为父工程不需要写任何代码

#### pom.xml

```
<!-- SpringBoot-整合Web组件 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<!-- springcloud feign组件 -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

## 创建服务接口工程

1. 在mingrui-shop-parent 工程名上右键-->new-->module 

2. 项目名为: mingrui-shop-service-api

   #### 删除src文件夹

   父工程不需要写任何代码

   #### pom.xml

   ```
   <!-- SpringBoot-整合Web组件 -->
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
   </dependency>
   ```

## 创建注册中心(eureka)服务

在mingrui-shop-basics工程名上右键-->new-->module

注意:要在mingrui-shop-basics工程下

#### pom.xml

```
<dependencies>
    <!--eureka 服务依赖-->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
    </dependency>
</dependencies>
```



#### 创建application.yml文件

```
server:
  port: 8761 #端口号


spring:
  application:
    name: eureka-server #服务名称

eureka:
  client:
    # eureka服务url,值为map集合默认key为defaultZone
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka
    # 当前服务是否同时注册
    register-with-eureka: false
    # 去注册中心获取其他服务的地址
    fetch-registry: false
  instance:
    hostname: localhost
    # 定义服务续约任务（心跳）的调用间隔，单位：秒 默认30
    lease-renewal-interval-in-seconds: 1
    # 定义服务失效的时间，单位：秒 默认90
    lease-expiration-duration-in-seconds: 2
  server:
    # 测试时关闭自我保护机制，保证不可用服务及时踢出
    enable-self-preservation: false
```

#### 创建eureka的启动类

​	

```
@SpringBootApplication
@EnableEurekaServer //说明他是一个注册中心
public class RunEurekaServerApplication {
    public static void main(String[] args) {
    SpringApplication.run(RunEurekaServerApplication.class);
    }
}
```



使用nginx反向代理

## 域名文件hosts文件的地址

Windows下的hosts文件地址:C:/Windows/System32/drivers/etc/hosts

Linux下的hosts文件所在路径： /etc/hosts

## 在hosts文件内添加

添加了两个映射关系： 

127.0.0.1 api.mrshop.com ：我们的网关Zuul 

127.0.0.1 manage.shop.com：我们的后台系统地址

测试一下 ping一下域名是否畅通

ping api.mrshop.com

返回信息是来自127.0.0.1的回复:字节=32 <1ms TTl = 128

## 测试

启动vue项目

输入域名 + vue的端口号测试

如果显示invalid Host Header

就打开build文件下webpack.dev.conf.js文件在debServer中加入

**disableHostCheck : true,**

再次编译项目就会启动成功

## nginx解决端口问题

我们希望访问的是manage.mrshop.com 这种情况下的端口号是80 请求转移到9001端口

要用到nginx反向代理工具

## nginx作为反向代理

**什么是反向代理?**

​	代理：通过客户机的配置，实现让一台服务器代理客户机，客户的所有请求都交给代理服务器处理。 

​	反向代理：用一台服务器，代理真实服务器，用户访问时，不再是访问真实服务器，而是代理服务 器。 

**nginx可以当做反向代理服务器来使用：**

​				 我们需要提前在nginx中配置好反向代理的规则，不同的请求，交给不同的真实服务器处理 当请求到达nginx，nginx会根据已经定义的规则进行请求的转发，从而实现路由功能

## 使用nginx

nginx可以通过命令行来启动，

​	**操作命令：** 

​		<b>启动： start nginx.exe</b> 

​		<font color="red">停止： nginx.exe -s stop </font>

​		重新加载： nginx.exe -s reload

## 配置nginx


       worker_processes  1;
    events {
        worker_connections  1024;
    }
    http {
        include       mime.types;
        default_type  application/octet-stream;
       
       sendfile        on;
    keepalive_timeout 65;
    
    server {
        listen       80;
        server_name manage.mrshop.com;


​       
​       proxy_set_header X-Forwarded-Host $host;
​    	proxy_set_header X-Forwarded-Server $host;
​    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
​        
​        location / {
​    		proxy_pass http://127.0.0.1:9002;
​    		proxy_connect_timeout 600;
​    		proxy_read_timeout 600;
​        }
​    	
    }
    
    server {
    		listen 80;
    		server_name api.mrshop.com;
    		
    		proxy_set_header X-Forwarded-Host $host;
    		proxy_set_header X-Forwarded-Server $host;
    		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    		
    		location / {
    			proxy_pass http://127.0.0.1:8088;
    			proxy_connect_timeout 600;
    			proxy_read_timeout 600;
    		}
    		
    		location /api-xxx/upload {
    			proxy_pass http://127.0.0.1:8200;
    			proxy_connect_timeout 600;
    			proxy_read_timeout 600;
    			rewrite "^/api-xxx/(.*)$" /$1 break;
    		}
    
    	}
    
    server {
    	listen 80;
    	server_name image.mrshop.com;
    	
    	proxy_set_header X-Forwarded-Host $host;
    	proxy_set_header X-Forwarded-Server $host;
    	proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    	location ~ .*\.(gif|jpg|pdf|jpeg|png)$
    	
    	{
    
    	root D:\images;
    	}
    	location / {
    	root html;
    	index index.html index.htm;
    	}
    	}
    }
## 测试

浏览器输入http://manage.mrshop.com/

出来效果即可成功

## mingrui-shop-common-core工程

####  在mingrui-shop--commons项目下新建mingrui-shopcommon-core项目

#### pom.xml

```
<dependencies>

<!--处理json与各种数据类型或文档类型的转换-->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.5</version>
</dependency>
<!--json对象序列化和反序列化的支持-->
<dependency>
    <groupId>org.codehaus.jackson</groupId>
    <artifactId>jackson-core-lgpl</artifactId>
    <version>1.9.13</version>
</dependency>
<dependency>
<groupId>org.codehaus.jackson</groupId>
    <artifactId>jackson-mapper-lgpl</artifactId>
    <version>1.9.13</version>
</dependency>
<!--java对象和json对象之间的转换-->
<dependency>
    <groupId>org.codehaus.jackson</groupId>
    <artifactId>jackson-core-asl</artifactId>
    <version>1.9.13</version>
</dependency>
<dependency>
    <groupId>org.codehaus.jackson</groupId>
    <artifactId>jackson-mapper-asl</artifactId>
    <version>1.9.13</version>
</dependency>
<!--alibaba的json处理工具-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.62</version>
</dependency>
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.11.2</version>
</dependency>

    <!-- SpringBoot-整合Web组件 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--帮助开发人员快速生成API文档-->
    <dependency>
        <groupId>io.springfox</groupId>
        <artifactId>springfox-swagger2</artifactId>
        <version>2.9.2</version>
    </dependency>
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper</artifactId>
        <version>5.1.8</version>
        <scope>compile</scope>
    </dependency>

    <dependency>
        <groupId>com.belerweb</groupId>
        <artifactId>pinyin4j</artifactId>
        <version>2.5.1</version>
    </dependency>


</dependencies>
```

##### 新建包com.baidu.shop.utils

##### JSONUtil

```java
private static Gson gson = null;
static {
    gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create();// todo yyyy-MM-dd HH:mm:ss
}
public static synchronized Gson newInstance() {
    if (gson == null) {
        gson = new GsonBuilder().setDateFormat("yyyy-MM-dd HH:mm:ss").create();
    }
    return gson;
}
public static String toJsonString(Object obj) {
    return gson.toJson(obj);
}
public static <T> T toBean(String json, Class<T> clz) {
    return gson.fromJson(json, clz);
}
public static <T> Map<String, T> toMap(String json, Class<T> clz) {
    Map<String, JsonObject> map = gson.fromJson(json, new
            TypeToken<Map<String, JsonObject>>() {
            }.getType());
    Map<String, T> result = new HashMap<String, T>();
    for (String key : map.keySet()) {
        result.put(key, gson.fromJson(map.get(key), clz));
    }
    return result;
}
public static Map<String, Object> toMap(String json) {
    Map<String, Object> map = gson.fromJson(json, new TypeToken<Map<String,
                    Object>>() {
    }.getType());
    return map;
}
public static <T> List<T> toList(String json, Class<T> clz) {
    JsonArray array = new JsonParser().parse(json).getAsJsonArray();
    List<T> list = new ArrayList<T>();
    for (final JsonElement elem : array) {
        list.add(gson.fromJson(elem, clz));
    }
    return list;
}
/**
 * 从json字符串中获取需要的值
 *
 * @param json
 * @param clazz 要转换的类型
 * @return
 */
public static <T> Object getObjectByKey(String json, Class<T> clazz) {
    if (json != null && !"".equals(json)) {
        return JSONObject.parseObject(json, clazz);
    }
    return null;
}
/**
 * 从json字符串中获取需要的值
 *
 * @param json
 * @param clazz 要转换的类型
 * @return
 */
public static <T> List<T> getListByKey(String json, Class<T> clazz) {
    if (json != null && !"".equals(json)) {
        return JSONObject.parseArray(json, clazz);
    }
    return null;
}
/**
 * 从json字符串中获取需要的值
 *
 * @param json
 * @param key
 * 键
 * @return
 */
public static String getStrByKey(String json, String key) {
    String str = "";
    if (json != null && !"".equals(json)) {
        JSONObject j = JSONObject.parseObject(json);
        if (j.get(key) != null) {
            str = j.get(key).toString();
        }
    }
    return str;
}
/**
 * 向文件中写数据
 *
 * @param _sDestFile
 * @param _sContent
 * @throws IOException
 */
public static void writeByFileOutputStream(String _sDestFile, String
        _sContent) throws IOException {
    FileOutputStream fos = null;
    try {
        fos = new FileOutputStream(_sDestFile);
        fos.write(_sContent.getBytes());
    } catch (Exception ex) {
        ex.printStackTrace();
    } finally {
        if (fos != null) {fos.close();
            fos = null;
        }
    }
}
/**
 * 非空
 *
 * @param str
 * @return true:不为空 false：空
 */
public static boolean noEmpty(String str) {
    boolean flag = true;
    if ("".equals(str)) {
        flag = false;
    }
    return flag;
}
/**
 * 将"%"去掉
 *
 * @param str
 * @return
 */
public static double getDecimalByPercentage(String str) {
    double fuse = 0.0;
    if (!"".equals(str) && str != null) {
        if (str.split("%").length > 0) {
            fuse = Double.parseDouble(str.split("%")[0]);
            return fuse;
        }
    }
    return 0.0;
}
/**
 * 保留2位小数
 *
 * @param number
 * @return
 */
public static double ConversionFraction(double number) {
    return Math.floor(number * 100 + 0.5) / 100;
}
public static float ConversionM(double number) {
    return (float) JSONUtil.ConversionFraction(number / 1024 / 1024);
}
public static String getErrorText(String s) {
    JSONObject j = JSONObject.parseObject(s);
    return
            j.getJSONObject(j.keySet().iterator().next()).get("errortext").toString();
}public static String getSingleJobId(String s) throws Exception {
    JSONObject j = JSONObject.parseObject(s);
    try {
        return
                j.getJSONObject(j.keySet().iterator().next()).get("jobid").toString();
    } catch (Exception e) {
        try {
            return
                    j.getJSONObject(j.keySet().iterator().next()).get("errortext").toString();
        } catch (Exception e1) {
            throw new Exception(e1.getMessage());
        }
    }
}
public static <T> T readValue(String jsonStr, TypeReference type)
        throws JsonParseException, JsonMappingException, IOException {
    ObjectMapper mapper = new ObjectMapper();
    return mapper.readValue(jsonStr, type);
}
public static JSON_TYPE getJSONType(String str) {
    if (null == str || "".equals(str)) {
        return JSON_TYPE.JSON_TYPE_ERROR;
    }
    final char[] strChar = str.substring(0, 1).toCharArray();
    final char firstChar = strChar[0];
    if (firstChar == '{') {
        return JSON_TYPE.JSON_TYPE_OBJECT;
    } else if (firstChar == '[') {
        return JSON_TYPE.JSON_TYPE_ARRAY;
    } else {
        return JSON_TYPE.JSON_TYPE_ERROR;
    }
}
public enum JSON_TYPE {
    /** JSONObject */
    JSON_TYPE_OBJECT,
    /** JSONArray */
    JSON_TYPE_ARRAY,
    /** 不是JSON格式的字符串 */
    JSON_TYPE_ERROR
}
```

##### 新建包com.baidu.shop.status

##### HTTPStatus

```java
public static final int OK = 200;//成功
public static final int ERROR = 500;//失败
```

操作成功显示的状态码

操作失败显示的状态码

##### 新建包com.baidu.shop.base

##### Result

```java
private Integer code;//返回码
private String message;//返回消息
private T data;//返回数据
public Result(Integer code, String message, Object data) {
    this.code = code;
    this.message = message;
    this.data = (T) data;
}
```

##### BaseApiService

```java
public Result<T> setResultError(Integer code, String msg) {
    return setResult(code, msg, null);
}
// 返回错误，可以传msg
public Result<T> setResultError(String msg) {
    return setResult(HTTPStatus.ERROR, msg, null);
}
// 返回成功，可以传data值
public Result<T> setResultSuccess(T data) {
    return setResult(HTTPStatus.OK, HTTPStatus.OK + "", data);
}
// 返回成功，沒有data值
public Result<T> setResultSuccess() {
    return setResult(HTTPStatus.OK, HTTPStatus.OK + "", null);
}
// 返回成功，沒有data值
public Result<T> setResultSuccess(String msg) {
    return setResult(HTTPStatus.OK, msg, null);
}
// 通用封装
public Result<T> setResult(Integer code, String msg, T data) {
    log.info(String.format("{code : %s , msg : %s , data : %s}",code,msg,
            JSONUtil.toJsonString(data)));
    return new Result<T>(code, msg, data);
}
```

执行失败或成功后返回的数据

## service-api工程

### mingrui-shop-service-api

### pom.xml

```java
<dependencies>
    <!-- SpringBoot-整合Web组件 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--Entity 中的@Table 和@Id需要次注解-->
    <dependency>
        <groupId>javax.persistence</groupId>
        <artifactId>persistence-api</artifactId>
        <version>1.0.2</version>
    </dependency>

    <!--2.3版本之后web删除了验证插件-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!--引入common工程代码-->
    <dependency>
        <groupId>com.baidu</groupId>
        <artifactId>mingrui-shopcommon-core</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>

    <!--分页工具-->
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper-spring-boot-starter</artifactId>
        <version>1.2.10</version>
    </dependency>


</dependencies>
```

###  在mingrui-shop-service-api项目下新建mingrui-shopservice-api-xxx项目

#### pom.xml

```java
    <dependencies>
<!--帮助开发人员快速生成API文档-->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>
<!--提供可视化的API文档-->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
    </dependencies>
```

####  新建包com.baidu.shop.entity

实体类

#### 新建包com.baidu.shop. swagger2

```java
@Configuration
@EnableSwagger2
public class MrSwagger2Config {
    @Bean
    public Docket createRestApi(){
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(this.apiInfo()).select()
                .apis(RequestHandlerSelectors.basePackage("com.baidu"))
                .paths(PathSelectors.any())
                .build();
    }
    private ApiInfo apiInfo(){
        return new ApiInfoBuilder()
                //标题
                .title("明瑞SWAGGER2标题")
                 //条款地址
                .termsOfServiceUrl("http://www.baidu.com")
                //联系方式-->有String参数的方法但是已经过时，所以不推荐使用
                .contact(new
                        Contact("wangxin","baidu.com","wangxinjiangming@126.com"))
                //版本
                .version("v1.0")
                //项目描述
                .description("描述")
                //创建API基本信息
                .build();
    }

}
```

####  定义商品分类接口

关于个分类的接口

##  service工程

###  mingrui-shop-service/pom.xml 

```xml
<dependencies>
    <!-- SpringBoot-整合Web组件 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <!-- springcloud feign组件 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-openfeign</artifactId>
    </dependency>

    <!--mysql数据库连接-->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <scope>runtime</scope><!--项目运行阶段使用-->
        <version>5.1.30</version>
    </dependency>
    <!--通用mapper-->
    <dependency>
        <groupId>tk.mybatis</groupId>
        <artifactId>mapper-spring-boot-starter</artifactId>
        <version>2.1.5</version>
    </dependency>
    <!--分页工具-->
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper-spring-boot-starter</artifactId>
        <version>1.2.10</version>
    </dependency>
    <dependency>
        <groupId>com.baidu</groupId>
        <artifactId>mingrui-shop-service-api-xxx</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>



</dependencies>
```

####  在mingrui-shop-service工程下新建mingrui-shop-servicexxx工程

```yml
server:
  port: 8100

spring:
  application:
    name: xxx-server
  # 配置数据源
  datasource:
    # 数据源名称，任意
    name: mysql
    url: jdbc:mysql://localhost:3306/2005?useUnicode=true&characterEncoding=utf8
    # 数据库连接用户
    username: root
    # 数据库连接密码
    password: root
    # 驱动名称
    driver-class-name: com.mysql.jdbc.Driver
    # boot2.0+使用hikari作为默认数据库连接池
    type: com.zaxxer.hikari.HikariDataSource
    hikari:
      # 是否自动提交事务 默认
      auto-commit: true
      # 允许的最小连接数
      minimum-idle: 5
      # 连接池内最大连接数
      maximum-pool-size: 10
      # 验证连接的sql语句
      connection-test-query: SELECT 1 FROM DUAL
      # 连接超时时间 默认30000 毫秒 如果小于250毫秒，则被重置回30秒
      connection-timeout: 30000
      # 验证超时时间默认5000毫秒 如果小于250毫秒，则会被重置回5秒
      validation-timeout: 5000
      # 设置连接在连接池中的存货时间 如果不等于0且小于30秒则会被重置回30分钟
      max-lifetime: 1800000

# 通用mapper
mapper:
  mappers: tk.mybatis.mapper.common.Mapper
  identity: MYSQL
#日志设置
logging:
  level:
    # 打印与我们程序相关的日志信息
    com.baidu.shop: debug
# eureka配置
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka/
```

#### 新建启动类

```java
@SpringBootApplication
@EnableEurekaClient
@MapperScan("com.baidu.shop.mapper")
public class RunXXXApplication {
    public static void main(String[] args) {
        SpringApplication.run(RunXXXApplication.class);
    }
}
```

#### 在com.baidu下新建包shop.mapper

mapper文件

####  在com.baidu下新建包shop.service.impl

继承BaseApiService,实现在api穿件的接口,





# 品牌中的上传图片

图片上传说白了就是文件上传 有可能每个服务都会有涉及到文件上传的操作 所以我们把文件上传抽出来作为一个公共的文件上传服务

## 在mingrui-shop-basics下新建mingrui-shop-basic-uploadserver

### pom.xml

```
<!-- SpringBoot-整合Web组件 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
<dependency>
    <groupId>com.baidu</groupId>
    <artifactId>mingrui-shopcommon-core</artifactId>
    <version>1.0-SNAPSHOT</version>
</dependency>
```

### application.yml

```
server:
  port: 8200
spring:
  application:
    name: upload-server

eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka


mingrui:
  upload:
    path:
      windows: D:\\images
      linux: /wangxin/images
    img:
      host: http://81.70.211.185/
```

### 启动类

```java
@SpringBootApplication
@EnableEurekaClient
public class RunUploadServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(RunUploadServerApplication.class);
    }
}
```

### 新建包com.baidu.shop.upload.controller

#### UploadController

```java
@RestController
@RequestMapping(value = "upload")
public class UploadController extends BaseApiService {
    //linux系统的上传目录
    @Value(value = "${mingrui.upload.path.windows}")
    private String windowsPath;
    //window系统的上传目录
    @Value(value = "${mingrui.upload.path.linux}")
    private String linuxPath;
    //图片服务器的地址/    @Value(value = "${mingrui.upload.img.host}")
    private String imgHost;
    @PostMapping
    public Result<String> uploadImg(@RequestParam MultipartFile file) {
        if(file.isEmpty()) return this.setResultError("上传的文件为空");//判断上传的文件是否为空
        String filename = file.getOriginalFilename();//获取文件名
        String path = "";
        String os = System.getProperty("os.name").toLowerCase();
        if(os.indexOf("win") != -1){
            path = windowsPath;
        }else if(os.indexOf("lin") != -1){
            path = linuxPath;
        }
        filename = UUID.randomUUID() + filename;//防止文件名重复
//创建文件 路径+分隔符(linux和window的目录分隔符不一样)+文件名
        File dest = new File(path + File.separator + filename);
//判断文件夹是否存在,不存在的话就创建
        if(!dest.getParentFile().exists()) dest.getParentFile().mkdirs();
        try {
            file.transferTo(dest);//上传
        } catch (IllegalStateException e) {
// TODO Auto-generated catch block
            e.printStackTrace();
        } catch (IOException e) {
// TODO Auto-generated catch block
            e.printStackTrace();
        }
        return this.setResult(HTTPStatus.OK,"upload success!!!",imgHost + "/" +
                filename);//将文件名返回页面用于页面回显
    }
}
```

### 新建包com.baidu.global

#### GlobalCorsConfig

```java
@Configuration
public class GlobalCorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        final UrlBasedCorsConfigurationSource source = new
                UrlBasedCorsConfigurationSource();
        final CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true); // 允许cookies跨域
        config.addAllowedOrigin("*");// 允许向该服务器提交请求的URI，*表示全部允许。。这里尽量限制来源域，比如http://xxxx:8080 ,以降低安全风险。。
        config.addAllowedHeader("*");// 允许访问的头信息,*表示全部
        config.setMaxAge(18000L);// 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了
        config.addAllowedMethod("*");// 允许提交请求的方法，*表示全部允许，也可以单独设置GET、PUT等
        config.addAllowedMethod("HEAD");
        config.addAllowedMethod("GET");// 允许Get的请求方法
        config.addAllowedMethod("PUT");
        config.addAllowedMethod("POST");
        config.addAllowedMethod("DELETE");
        config.addAllowedMethod("PATCH");
        source.registerCorsConfiguration("/**", config);
//3.返回新的CorsFilter.
        return new CorsFilter(source);
    }

}
```

### 使用postman测试

127.0.0.1.8200/upload



## 我们可以使用nginx来做代理服务

### 在hosts文件中新增

127.0.0.1 image.mrshop.com

### nginx-home/conf/nginx.conf新增

	server {
		listen 80;
		server_name image.mrshop.com;
		
		proxy_set_header X-Forwarded-Host $host;
		proxy_set_header X-Forwarded-Server $host;
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			location ~ .*\.(gif|jpg|pdf|jpeg|png)$
		
		{
	
			root D:\images;
		}
		location / {
			root html;
			index index.html index.htm;
		}
	}
### 重启nginx

nginx.exe -s reload

### 在浏览器输入

输入http://image.mrshop.com/imageName.jpg出来图片即可成功



# 修改文件上传服务

## fastDFS

## 什么是fastDFS

FastDFS是由淘宝的余庆先生所开发的一个轻量级、高性能的开源分布式文件系统。用纯C语言开发， 功能丰富： 

文件存储

文件同步 

文件访问（上传、下载） 

存取负载均衡 在线扩容 

适合有大容量存储需求的应用或系统。同类的分布式文件系统有谷歌的GFS、HDFS（Hadoop）、 TFS（淘宝）等。

## 解压fastDFS压缩包得到压缩文件

##### 在linux系统中自己的目录下新建fastDFS目录

mkdir fastDFS

##### 进入fastDFS目录

cd fastDFS/

##### 将刚刚解压得到的压缩包全部上传到此文件内

##### 安装C/C++ 编译环境

yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake

##### 安装libevent

yum -y install libevent

#####  安装 libfastcommon

tar -xvf libfastcommon-master.tar #解压压缩包

cd libfastcommon-master/ #进入目录

./make.sh #编译

./make.sh install #安装

cp /usr/lib64/libfastcommon.so /usr/lib #复制镜像

##### 安装FastDFS

cd .. #进入fastDFS目录

tar -zxvf FastDFS_v5.08.tar.gz #解压压缩包

cd FastDFS/ #进入目录

./make.sh #编译

./make.sh install #安装

##### 1 启动tracker

cd /etc/fdfs #进入fastDFS配置目录 

cp tracker.conf.sample tracker.conf #复制文件 

vi tracker.conf #编辑刚刚复制的配置文件

###### 修改配置

base_path=/shop/fdfs/tracker

###### 保存并退出文件

###### 创建刚刚设置的目录

##### 启动tracker

mkdir -p /shop/fdfs/tracker

##### 启动storage

cp storage.conf.sample storage.conf 

vi storage.conf

###### 修改配置

base_path=/shop/fdfs/storage 

store_path0=/shop/fdfs/storage

 tracker_server=本机ip地址:22122 #注意不能写localhost,需要写ip地址

###### 保存并退出 

###### 创建刚刚设置的目录

mkdir -p /shop/fdfs/storage

###### 启动storage

service fdfs_storaged start

##### 查看进程

ps -ef | grep fdfs

<font color="red">有三个即为正确</font>

#####  安装FastDFS的Nginx模块

###### 进入压缩包所在的目录

tar -zxvf fastdfs-nginx-module_v1.16.tar.gz #解压压缩包 

cd fastdfs-nginx-module/src/ #进入目录 

vi config //直接输入下面的命令,注意冒号需要手敲 : --> %s+/usr/local/+/usr/+g --> enter --> esc --> :wq --> enter

###### 保存并退出

cp mod_fastdfs.conf /etc/fdfs/ #复制文件 

vi /etc/fdfs/mod_fastdfs.conf

###### 修改默认配置

connect_timeout=10 

tracker_server=本机ip地址:22122 #不能写localhost 

url_have_group_name = true 

store_path0=/shop/fdfs/storage

###### 保存并退出

###### 进入FastDFS/conf目录

cp http.conf mime.types /etc/fdfs/ #复制文件

##### 安装Nginx

###### 进入压缩包所在的目录

tar -zxvf nginx-1.10.0.tar.gz #解压压缩包 

yum -y install make zlib-devel libtool openssl openssl-devel #安装依赖 

cd nginx-1.10.0/ 

./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/wangxin/fastDFS/fastdfs-nginx-module/src

注意: 

--prefix= --> nginx配置文件所在目录 

--sbin-path= --> 执行程序文件所在目录 

--add-module= -->外部模块路径，启用对外部模块的支持 这个路径一定不能配置错,就写你自己 fastdfs-nginx-module的目录即可

make && make install #编译并安装

##### 编辑nginx的配置文件

vi /opt/nginx/conf/nginx.conf

##### server的配置

listen 80;

 server_name localhost:8888;#storage的端口号 

监听域名中带有group的，交给FastDFS模块处理 

location ~/group([0-9])/ {

 ngx_fastdfs_module;

 }

###### cd /opt/nginx #nginx主目录

##### 启动nginx

nginx

 nginx -s stop #停止

nginx -s reload #重新加载配置

##### 上传成功后使用posemain测试

输入linuxIP加文件路径测试

# Elasticsearch介绍和安装

Elasticsearch是一个基于Apache Lucene(TM)的开源搜索引擎。Lucene是迄今为止最先进、性能、 功能 上来讲最全的搜索引擎库。 但是，Lucene只是一个库。想要使用它，你必须使用Java来作为开发 语言并将其直接集成到你的应用中，（以导入jar包的形式），Lucene非常复杂，你需要深入了解检索 的相关知识来理解它是如何工作的。 Elasticsearch也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，是一个独立的 web项目。但是它的使用方式是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得 简单。 Elasticsearch不仅仅是Lucene和全文搜索，我们还能这样去描述它： 

分布式的实时(快!)文件存储，每个字段都被索引并可被搜索 

分布式的实时分析搜索引擎 

可以扩展到上百台服务器，处理PB级结构化或非结构化数据

## Elasticsearch特点

分布式，无需人工搭建集群 

Restful风格，一切API都遵循Rest原则，容易上手 

近实时搜索，数据更新在Elasticsearch中几乎是完全同步的。 

Elasticsearch 是一个分布式的搜索引擎，底层基于lucene,主要特点是可以完成全文检索， 

支持海量数据pb级别，横向拓展，数据分片，等一系列功能、

 良好的查询机制，支持模糊，区间，排序，分组，分页，等常规功能 

横向可扩展性：只需要增加一台服务器，做一点儿配置，启动一下ES进程就可以并入集 

分片机制提供更好的分布性：同一个索引分成多个分片（sharding），这点类似于HDFS的块机 制；分而治之的方式来提升处理效率，相信大家都不会陌生；

### 不足

没有细致的权限管理机制,没有像MySQL那样的分各种用户，每个用户有不同的权限 单台节点部署的话，并发查询效率并不高，

### 使用场景：

爱奇艺搜电影，京东搜手机，qq搜好友，百度地址各种信息，嘀嘀打车，邮件搜索，微信还有，美团饭 店，旅游景点，可以说，搜索场景无处不在

## 安装和配置

为了模拟真实场景，我们将在linux下安装Elasticsearch。

### 安装es

将压缩包上传到linux系统中

tar -zxvf elasticsearch-7.5.1-linux-x86_64.tar.gz #解压压缩包 

groupadd esgroup #创建用户组 

useradd esuser -g esgroup -p 123456 #在用户组下新建用户 

cd elasticsearch-7.5.1/config/ #进入配置文件目录 

vi jvm.options #修改JVM参数(默认1G) 

-Xms512m 

-Xmx512m

#### 保存并退出

vi elasticsearch.yml 

cluster.name: my-application #集群名称 

node.name: node-1 #当前节点名称 

path.data: /shenyaqi/es/elasticsearch-7.5.1/data #数据存放目录 

path.logs: /shenyaqi/es/elasticsearch-7.5.1/logs #日志目录 

network.host: 0.0.0.0 #允许任意ip访问 

discovery.seed_hosts: ["119.45.191.248"] #所有节点ip,由于当前环境采用单节点,所以只写当 前节点ip地址 

cluster.initial_master_nodes: ["node-1"] #声明master节点,由于当前是单节点环境所以 master节点就是当前节点[此处可以写ip:9200也可以写node.name]

###### 保存并退出

cd ../../ #进入es的上级目录

chown -R esuser:esgroup elasticsearch-7.5.1 #给用户授权 

su esuser #切换用户

cd elasticsearch-7.5.1/bin/ #进入bin目录 

./elasticsearch 启动es

##### 会出现错误max virtual memory areas....

###### 如果出现上图错误

su root 

sysctl -w vm.max_map_count=262144 

sysctl -a|grep vm.max_map_count 

su esuser

浏览器访问ip:9200

###### 可以看到东西就成功

###  安装ik分词器

进入es目录下的plugins目录

mkdir ik 

cd ik

###### 将elasticsearch-analysis-ik-7.5.1.zip上传到ik目录

unzip elasticsearch-analysis-ik-7.5.1.zip #解压压缩包 

##### 解压完成之后最好切换回root 用户重新给文件夹授权

rm -rf elasticsearch-analysis-ik-7.5.1.zip #删除压缩包

cd ..

cd ..

chown -R esuser:esgroup elasticsearch-7.5.1 #给用户授权 

su esuser #切换用户

cd ../bin/ 

./elasticsearch 

./elasticsearch -d #后台启动

###### 查看日志如果有loaded plugin [analysis-ik] 安装成功

#### 安装kibana(可视化工具)

######  什么是kibana

Kibana是一个基于Node.js的Elasticsearch索引库数据统计工具，可以利用Elasticsearch的聚合功能， 生成各种图表，如柱形图，线状图，饼图等。 

而且还提供了操作Elasticsearch索引数据的控制台，并且提供了一定的API提示，非常有利于我们学习 Elasticsearch的语法。

#### 安装

因为Kibana依赖于node，我们的虚拟机没有安装node，而window中安装过。所以我们选择在window 下使用kibana

####  配置运行

进入安装目录下的config目录，修改kibana.yml文件：

修改elasticsearch服务器的地址：

elasticsearch.hosts: ["http://119.45.191.248:9200"] #119.45.191.248替换成自己虚拟的 IP地址

###### 进入安装目录下的bin目录：

启动kinbana.bat脚本文件

#####  测试分词器和kibana

浏览器输入127.0.0.1:5601

`GET _search 

{

​	 "query": { 

​	"match_all": {} 

​	} 

} 

POST _analyze {

 "analyzer": "ik_max_word",

 "text": "我爱北京天安门"

 }`

点击播放那个按钮,如果有就执行成功